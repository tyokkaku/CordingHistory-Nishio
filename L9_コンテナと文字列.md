# 第9章　コンテナと文字列

## 9.1　いろいろな種類のコンテナがある

## 9.2　なぜいろいろな種類のコンテナがあるのか

コンテナに入れられたデータは、メモリに格納される。コンテナの種類によってメモリへの格納の仕方が異なり、それぞれにはメリットとデメリットがある。

### 配列と連結リスト

配列の値は、順番に並んでメモリに格納される。

100 101 102
 A   B   C

連結リストの値は、値の次に「次の値が格納されたメモリ番号」が格納されている。（したがって、連結リストは配列の2倍のメモリを使う）

100 101 102 103 104 105
 A  104  C   0   B  102

### 配列に値を挿入する場合

100 101 102
 A   B   C

100 101 102 103
 A   Z   B   C

挿入してズレた分だけ、メモリの番号が異なるので、コピーして格納しなくてはならない。10000個の要素の先頭に挿入したら、10000個分のズレのコピーが必要

### 連結リストに値を挿入する場合

100 101 102 103 104 105 106 107
 A  106  B  104  C   0   Z  102

 Zと「Zの次の値の番号」を空いたメモリ番号に格納し、直前の値の番号指定をZに変更する。

## 連結リストの長所と短所

- 配列：要素の取得は高速だが、要素の挿入や削除は低速
- 連結リスト：要素の挿入や削除は高速だが、要素の取得は低速

## 9.3　辞書，ハッシュ，連想配列

値とキーをセットにして格納する連想配列の実現のために、よく使われているのが、ハッシュテーブルと木である。

### ハッシュテーブル

1. 値を入れるための大きな配列を用意する
2. ハッシュ関数を使って、文字列を「ハッシュ値」に変換する
3. ハッシュ値と同値の配列の番号に、値を格納する

結果、文字列は配列の番号となり、その番号には値が格納される。値と文字列が対応する。

### 木

キー同士を比較して、小さければ左と、大きければ右と連結する。

1. 木構造のルートに文字列と値をセットする
2. 次のデータのキーを比較して、小さければ左と、大きければ右と繋ぐ

データを取り出す際は、ルートから「大きいか小さいか」を繰り返して探索する。

### 要素を取り出す時間

配列で実現すると、どうなるか？：キー、値、キー、値と入れていく。

キーと値は紐づいていないため、要素の取り出しはO(n)となる。

### 木の場合

平衡状態：O(log n)
偏った状態：最悪でO(n)

### ハッシュテーブルの場合

キーと値は紐づいているため、取得はO(1)になる。
最も高速に取り出すことができるが、最初に「大きな配列」を用意しなくてはならないので、メモリ消費量も大きい。

## 9.4　文字とは何か

文字は、それを使う人たちの共通ルールの下で使われている。

文字の符号化は、「拡張」と「標準化」の力のせめぎあいで発展してきた。

## コンピュータ以前の符号化

### モールス符号

短点(ト)と長点(ツー)の組み合わせで文字を表現した。

### ボーコード

パンチテープ、読み取り機、テレックス。1931年。

1文字をオンオフ5つの組み合わせ表現した。SOSなら15ビットで表現できる。

また「シフト」するビット列があり、数字モードとアルファベットモードを切り替えられた。

### 統一までの過程

1. 1960年代にASCIIでアメリカは標準化（）
2. 標準化したものの、他のメーカーも異なる符号化方法を発表したので、さまざまな符号化方法が用いられるのが現実だった。
3. 各国で、各国の言語に合わせた符号化方法が発明される
  - 日本では、ISOやSHift_JIS_EUC-JPなど。
  - 言語処理系は、どの符号化方法を使っているのか分からないので、文字化け、エラーが多発。
  - マジックコメント(先頭に使用する符号化方法を明示する)で対応
4. 1990年代になって、世界共通のUnicodeが誕生して世界標準が定められた。

### 文字列の表現

C言語：末尾に0をつけて区切りとする。(文字の長さの情報を持たない)
  - 区切りのためのメモリを与える必要がある
Pascal：先頭に文字の長さの情報を持ち、長さ分を区切りとする

大部分の言語が、Pascal型の文字列を採用した。

### 文字列の問題に対するアプローチ

言語によって「文字列」が何を意味するのかは異なる。

- Java：16ビットのUnicode
- C言語：8ビットのASCIIとかEBCDICとかの文字
- Python3.0：基本的にはUnicode、しかし、bをつけて表現したらバイト列。混在させたらエラーを表示する。
- Ruby：8ビットの列であり、符号化方式の情報を追加で持つ。(そのため、Unicode以外にも互換性がある)

言語処理系が、符号化方法を知らないことが問題だった。

1. 言語処理系の実装で、符号化方法の情報を組み込めるようにする
2. そもそもUnicodeの「文字」を拡張して、範囲を広げる

