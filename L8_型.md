# 第8章　型

## 8.1　型とは何か

型とは、人間がデータにつけた「追加のデータ」のこと。

同じビット列でも、解釈の仕方が異なれば、違う値になる。これを避けるために、どういう種類の値かという情報を追加した。これが型の始まりだった。

## 8.2　数値をオンとオフで表現する方法

コンピュータは、オンとオフ、0と1の集まりですべての値を表現する。

「数値をランプの点灯と消灯で表現するにはどうしたらよいか？」

1カウントにつきランプを点灯させる。 => 999を表現するためには、999個のランプが必要になる

## 位取りの発明

1の位、10の位、100の位と分けて、「567」と並べて表現する。999を表現するには、1つの位につき9個ランプが必要なので、合計27個のランプが必要になる。

## 7セグメントディスプレイ

0から9までの数字は、7つの棒線で表現できる。棒線に、AからGなどの記号を割り当てる。7セグメントディスプレイでは、21個のランプが必要になる。

## そろばん

下の4つの玉で0〜4、上の1つの玉で5を足すか足さないか表現する。1の位につき5つ必要なので、3桁であれば、15個のランプが必要になる。

## 8.3　1つの位に必要なランプはいくつか？

1つのランプは、2通りの符号(消灯/点灯)を表現できる。表現できるのはランプの個数の階乗になる。1の位は10通り表現しなければならないため、ランプが4つ必要になり、3桁の場合は、12個のランプが必要になる。ただし、本来は16通り表現できるのに、10通りの表現しか使っていない。

- 10進法から2進法ヘ

位取りを、10進数から2進数に変える。

2進数であれば、10個のランプで1023()まで表現できる。(2の10乗は、1024)。8ビットは、2の8乗で256。現在のコンピュータは、32ビット、64ビットが主流になっている。

## 8.4　実数はどうやって表現しよう

### 固定小数点数──小数点がどこに付くか決める

小数点をどこに付けるかをあらかじめ決めておく。

### 浮動小数点数──どこからが小数部かの情報自体を値に含める

どこからが少数部かの情報自体を値に含める。

### どのような考え方か

符号 指数部 仮数部

○ ○○○○○○○○ ○○○○○○○○○○○○○○○○○○○○○○○

符号：1
指数部：8
仮数部：23

仮数部の左端から2つは、1/2と1/4をを表現する。2進数では、0.1と0.11を表現する。
1.75は、1 + 1/2 + 1/4と表現される。2進数では、1.11になる。

不動少数点数では、以下のように表現できる。
○ ○●●●●●●● ●●○○○○○○○○○○○○○○○○○○○○○

指数部は、127「小数点の位置を0個ずらす」を表現している。

1.75の二倍である3.5は、10進数で、2 + 1/2である。2進数では、11.1になる。

不動少数点数では、以下のように表現できる。
○ ●○○○○○○○ ●●○○○○○○○○○○○○○○○○○○○○○

指数部は128で「小数点を1桁右にずらす」を表現する 。1.75から1桁ずらすことで、1.11を表現している。

1桁ずれるごとに2倍になるので、7.0は、不動少数点数では、以下のように表現できる。
○ ●○○○○○○● ●●○○○○○○○○○○○○○○○○○○○○○

## 8.5　型は何のため？

コンピュータにとって、整数の7と少数の7.0はまったく異なる。

○●○○○○○○●●●○○○○○○○○○○○○○○○○○○○○○ : 少数の7.0

○○○○○○○○○○○○○○○○○○○○○○○○○○○○○●●● : 整数の7

コンピュータは、ビット列だけでは整数なのか浮動小数点数なのかどちらで解釈したらいいのか分からない。この情報を与えるために出来たのが型。

### 片方が整数で片方が浮動小数点数の演算

C言語では、暗黙に、整数を浮動小数点数に変換して計算した。ただし、変数の計算の時に、どちらになるのか人間が覚えておかなくてはならない。

### 書き方で区別する言語

pythonなどでは、/と//で、整数、浮動小数点数の計算を区別している。

### 8.6　型のいろいろな展開

### ユーザ定義型とオブジェクト指向

ユーザーが定義できる型(ユーザー定義型)は、クラスと名付けられた。これはオブジェクト指向の発明である。

### 仕様としての型

「型は仕様である」。ゆえにすべて公開しなくてもよい。外部とのやりとりをする部分だけを型として公開し、実装の詳細は隠しておく。

この考えが推し進められて、インタフェースに発展した。インタフェースにおいては、具体的な実装は持たない。

### 総称型，ジェネリクス，テンプレート

型は、上記のように色々と発展を遂げ、型を複合して作った複雑な型が作られるようになった。しかし、この複雑な型の一部だけを変えたい時、全部定義しなおすのは面倒である。このニーズを満たすために「構成要素の型の一部が変わる型」である総称型が誕生した。

```java
public class GenericsTest {
  pubic static void main(String[] args) {
    // Personに、int型string型が適用できる。
    Person<Integer> x = new Person<Integer>();
    x.something = 1;
    Person<String> y = new Person<String>();
    y.something = "hoge";
    System.out.println("x.something"); // -> 1
    System.out.println("y.something"); // -> hoge
  }

  class Person<T> { // ジェネリクス。書き直さなくてもよい
    public Integer age; // Personクラスは異なる型を組み合わせて作られている。
    public String name;
    public T something; // somethingの型だけを変えたい...。(この型を臨機応変に使いたい。色々なケースが考えられる。柔軟にしたい)ときは、ジェネリクスで仮引数をTとしておく。
  }
}
```

### 動的型付け

- 静的型付け：「値」に対して「値の種類の情報」を明示的に付与する
- 動的型付け：「値」と「値の種類の情報」がセットになっている

### どのように実現しているか

Pythonでは、どんな値も、PyObject型として扱えるようになっている。PyObjectの中には、値の種類を入れておく場所が用意されている。どれも同じPyObject型なので、メモリの上でも同じ型として扱うことができる。

### 型推論

コンパイル時の型チェックを捨てずに、かつ、めんどうくさい型宣言を減らしたい。というニーズに応えるもの。コンピュータが型を推論してくれる。型推論の方法は言語によって異なる。

### 8.7　まとめ

- コンピュータによる数値の表現の仕方
- 浮動小数点数
- 数値の種類の情報,型の必要性
- 型は「仕様」
- 型の発展（ジェネリクス、エラー処理、インタフェースなど）
- 静的型付け、動的型付け
- 型推論